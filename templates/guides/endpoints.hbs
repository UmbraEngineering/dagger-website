<div class="row content">
	<h2>Endpoints</h2>

	<div class="row">
		<div class="small-12 columns">
			<p>
				This guide is all about endpoints. Endpoints can be created using the <code>dagger create</code>
				command.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			{{#pre "bash"}}
				$ dagger create endpoint foo
			{{/pre}}
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				Inside the file, a dagger endpoint is an instance of the <code>Endpoint</code> class. This instance is given
				a <code>route</code> value which is the base URI that the endpoint responds to.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 medium-10 medium-offset-1 columns">
			<div class="file">
				<h3>endpoints/foo.js</h3>
				{{#pre "javascript"}}
					var Endpoint = require('dagger.js/lib/endpoint');

					var FooEndpoint = module.exports = new Endpoint({

						route: '/foo'

					});
				{{/pre}}
			</div>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				From there, you can define functions for handling different verbs and subroutes.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 medium-10 medium-offset-1 columns">
			<div class="file">
				<h3>endpoints/foo.js</h3>
				{{#pre "javascript"}}
					var Endpoint = require('dagger.js/lib/endpoint');

					var FooEndpoint = module.exports = new Endpoint({

						route: '/foo',

						'get': function(req) {
							// 
							// GET /foo
							//
						},

						'post /bar': function(req) {
							//
							// POST /foo/bar
							//
						},

						'put /:id': function(req) {
							//
							// PUT /foo/...
							//
						}

					});
				{{/pre}}
			</div>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				Each of your endpoint methods recieves a single argument when a request comes in which is a normalized
				request/response handler. This normalization is important due to the way that dagger can pass requests into
				your endpoints from both HTTP and Websockets. More about the <code>Request</code> class can be found in
				the <a href="/docs">documentation</a>.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				Let's create a basic endpoint that serves a JSON blob with a message.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 medium-10 medium-offset-1 columns">
			<div class="file">
				<h3>endpoints/foo.js</h3>
				{{#pre "javascript"}}
					var Endpoint = require('dagger.js/lib/endpoint');

					var FooEndpoint = module.exports = new Endpoint({

						route: '/foo',

						//
						// GET /foo
						//
						'get': function(req) {
							req.respond(200, {
								message: 'Hello, World!'
							});
						}

					});
				{{/pre}}
			</div>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				With the endpoint defined, you can make a request to the endpoint to try it out.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			{{#pre "http"}}
				GET http://example.com/foo HTTP/1.1
			{{/pre}}
			{{#pre "http"}}
				HTTP/1.1 200 OK
				Content-Type: application/json

				{
					"message": "Hello, World!"
				}
			{{/pre}}
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				Now, let's get a little fancier. We can modify the endpoint method to take a URI parameter.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 medium-10 medium-offset-1 columns">
			<div class="file">
				<h3>endpoints/foo.js</h3>
				{{#pre "javascript"}}
					var Endpoint = require('dagger.js/lib/endpoint');

					var FooEndpoint = module.exports = new Endpoint({

						route: '/foo',

						//
						// GET /foo/:id
						//
						'get /:id': function(req) {
							req.respond(200, {
								message: "You gave the parameter '" + req.params.id + "'"
							});
						}

					});
				{{/pre}}
			</div>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				When we make our test request this time, we give a URI parameter to match the new route, and the endpoint
				gives it right back.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			{{#pre "http"}}
				GET http://example.com/foo/bar HTTP/1.1
			{{/pre}}
			{{#pre "http"}}
				HTTP/1.1 200 OK
				Content-Type: application/json

				{
					"message": "You gave the parameter 'bar'"
				}
			{{/pre}}
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				You can also handle multiple HTTP verbs with a single function. A common example of this is handling
				<code>PUT</code> and <code>PATCH</code> requests in the same way. This is done by defining a list of
				verbs separated by pipe (<code>|</code>) characters.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 medium-10 medium-offset-1 columns">
			<div class="file">
				<h3>endpoints/foo.js</h3>
				{{#pre "javascript"}}
					var Endpoint = require('dagger.js/lib/endpoint');

					var FooEndpoint = module.exports = new Endpoint({

						route: '/foo',

						//
						// PUT /foo/:id
						// PATCH /foo/:id
						//
						'put|patch /:id': function(req) {
							req.respond(200, {
								message: "The request was made with the " + req.method + " method"
							});
						}

					});
				{{/pre}}
			</div>
		</div>
	</div>



	<h3 id="models">Model Endpoints</h3>

	<div class="row">
		<div class="small-12 columns">
			<p>
				You can use the scaffolding CLI to create an endpoint that is pre-built for basic RESTful operations. The
				following command generates an endpoint <code>/people</code> that handles all the standard <abbr
				title="Create, Read, Update, Destroy">CRUD</abbr> tasks for the model <code>person</code>.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			{{#pre "bash"}}
				$ dagger create endpoint people for person
			{{/pre}}
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				For more info about model endpoints, take a look at the <a href="/guides/cli">scaffolding guide</a> and
				<a href="/docs/cli">documentation</a>.
			</p>
		</div>
	</div>



	<h3 id="sockets">Endpoints and Websockets</h3>

	<div class="row">
		<div class="small-12 columns">
			<p>
				If you enable socket.io in your application config, you can use websockets to perform some extra tasks that
				couldn't be very easily accomplished without them. For example, you can use your websocket connection to listen
				for documents being created, edited, or destroyed in the database and immediately inform the client. However,
				another thing you can do with socket.io is make standard API calls. <em>Any request that you can make with
				HTTP in dagger can also be made using a websocket.</em> Applications that make a large volume of API calls
				may find that keeping a single socket connection open is much more efficient than opening a new HTTP request
				for every API call needed.
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				Looking at the example endpoint above, before we made a request to the endpoint with an HTTP request like this:
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			{{#pre "http"}}
				GET http://example.com/foo HTTP/1.1
			{{/pre}}
			{{#pre "http"}}
				HTTP/1.1 200 OK
				Content-Type: application/json

				{
					"message": "Hello, World!"
				}
			{{/pre}}
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				With websockets enabled in your application, that same request could be made using socket.io like this:
			</p>
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			{{#pre "javascript"}}
				var req = {
					method: 'get',
					url: '/foo'
				};

				socket.emit('request', req, function(res) {
					// "Hello, World!"
					console.log(res.body.message);
				});
			{{/pre}}
		</div>
	</div>

	<div class="row">
		<div class="small-12 columns">
			<p>
				For more info about using the websocket functionality in dagger, check out the <a href="/guides/websockets"
				>websockets guide</a>.
			</p>
		</div>
	</div>

	<hr />

	<div class="row">
		<div class="small-12 columns">
			<p>
				That covers all of the basics of endpoints; For more information you can look at the <a href="/docs/endpoint"
				>endpoint documentation</a>.
			</p>
		</div>
	</div>
</div>